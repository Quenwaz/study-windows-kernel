# DLL和进程的地址空间

dll由一组可供应用程序或其他dll使用的独立函数组成的源代码模块。 创建DLL文件映像时需要指定链接选项`/DLL`, 这个选项使生成DLL时与可执行文件生成差异信息。 

可执行程序在调用一个DLL中函数之前， 必须将该DLL文件映像映射到进程的地址空间中。通常有两种方法达到这一目的： 

- 隐式链接
- 显式链接

一旦系统将DLL文件映像映射到调用进程的地址空间后， 进程的所有线程就都可以调用DLL中的函数了。DLL中的任意函数创建的任意对象都为调用进程或线程所拥有。 如在DLL中调用了**VitualAlloc**, 系统会从调用进程地址空间中预定地址空间区域。 若之后撤销对DLL的映射， 那么这块空间区域仍保留预定状态。因为被预定区域为进程所拥有，只有当线程调用了VitualFree时才会被释放。

当运行同一个可执行程序多个实例时， 这些实例将不会共享可执行文件中的全局变量和静态变量。 Windows通过使用**写时复制**来保证这一点。

> 一个地址空间是由一个可执行模块和多个DLL模块构成。 在这些模块中有些会链接到C/C++运行库的静态版本， 有些为DLL版本。 甚至有些不需要C/C++运行库。 所以如下代码可能会出现异常:

```cpp
void* dllfunc()
{
    return (malloc(100));
}

void exefunc()
{
    void* pv = dllfunc();
    // some code....
    free(pv);
}
```

以上代码当所有模块都是引用的静态版本C/C++运行库， 则将出现异常。 若都是使用的动态库版本C/C++运行库则能够正常工作。 为了避免此类情况发生， 模块需同时提供申请与释放内存的接口。

究其根本， 为什么同时使用C/C++静态库版本时，会出现异常？ 因为C/C++运行库提供分配堆的API中利用`HeapAlloc`创建了私有堆, `new、delete、malloc、free`都是操作这个私有堆， 当进入模块的**_DllMainCRTStartup**方法时，此堆被创建。 而静态库时，模块多次被加载，各自创建了各自的堆；动态库仅会被加载一次， 所以仅创建了一次。  可调用`GetProcessHeap`验证此情况。 

上述说法源于博客[Windows内存体系--堆](https://blog.csdn.net/china_jeffery/article/details/79627032) 与 [Windows内存体系--跨MT模块的内存相互释放的问题](https://blog.csdn.net/china_jeffery/article/details/79656307)

# DLL工作方式

创建dll需要如下步骤：

1. 在头文件中声明需要导出的接口及对应数据结构
2. 在源文件中实现对应接口
3. 在构建dll模块的时候， 编译器会对每个源文件进行处理并各产生一个.obj模块
4. 链接器将所有obj模块内容合并起来， 产生一个单独的DLL映像文件。 这个映像文件包好DLL中所有二进制代码及全局变量。
5. 如果链接器检测到dll的源文件输出了至少一个函数或变量， 将会生成一个.lib文件。 这个文件很小， 仅仅列出了所有被导出的函数和变量的符号名。
6. 同时链接器会为dll文件嵌入一个导出符号表。 这个按字母顺序排列的**导出段(export section)**列出了导出的变量、函数和类的符号名。链接器还会保存相对虚拟地址(relative virtual address, RVA)， 表示每个符号可以在dll模块中何处找到。 `可使用dumpbin.exe -exports查看导出段`

而创建可执行程序的步骤如下：

1. 在所有引用了导出的函数、变量、数据结构或符号的源文件中， 必须包含由dll创建的头文件。
2. 创建源文件中实现包含在可执行模块中的函数和变量。
3. 在构建可执行模块的时候， 编译器会对每个源文件进行处理并产生一个.obj模块
4. 链接器将所有的objm模块内容合并起来产生一个可执行映像文件。 这个文件中包含了可执行文件中所有的二进制代码以及全局/静态变量， 且包含一个**导入段**， 列出了所需的dll模块名称， 还记录了被引用的函数和变量符号名。操作系统加载程序会加载这个导入段。 一旦dll和可执行模块都已构建完毕，程序就可运行了
5. 加载程序为程序创建一个进程实例， 创建一个对应的虚拟地址空间， 并将可执行模块映射到进程的地址空间中，加载程序接着解析可执行模块的导入段，对导入段中的每个dll， 加载程序会在用户的系统中对其定位， 并将其映射到进程的地址空间。 同时dll可导入其他dll， 因此dll模块可能有自己的导入段，并需将它所需的dll模块映射到进程的地址空间中。 
6. 一旦加载程序将可执行模块和所有dll模块映射到进程的地址空间之后，进程的主线程开始执行。

## 构建DLL模块

在实际开发中， 我们应**避免从dll中导出变量**， 因为这等于去掉了代码中的一个抽象层， 从而使得dll的代码更加难以维护。 另外， 只有当导出C++类的模块与导入C++类的模块所使用的**编译器是同一家厂商**时， 我们**才可以导出C++类**。否则应尽量避免从DLL中导出类。



要点:

- 导出的类、函数或变量， 需要前置声明**__declspec(dllexport)**
- 导入其他模块的导出类、函数或变量时， 需要前置声明**__declspec(dllimport)**， 但不必须， 可替代使用**extern**关键字。但**__declspec(dllimport)**效率稍高。
- 为避免C++编译器更改函数名或变量名， 需前置声明**extern "C"**



## 为非 Vitual C++工具包创建dll

在混合使用C和C++编程时， 需使用`extern "C"`。同时由于C++类的名称改编问题， 我们必须使用同一家编译器厂商提供的工具包。 

即使完全使用C编程， 但使用了不同的厂商工具包， 仍存在一个问题： 如在没有使用C++时， Microsoft的C编译器也会对C函数名称进行改编。 只有当我们的函数使用了 **__stdcall(WINAPI)**调用约定时，才会发生这种情况。 通常的改编方式是， 给函数名添加下划线前缀和一个特殊的后缀， 该后缀有一个@符号及参数的字节数组成:

```c
__declspec(dllexport) LONG __stdcall MyFunc(int a, int b);
```

以上函数导出后为`_MyFunc@8`







