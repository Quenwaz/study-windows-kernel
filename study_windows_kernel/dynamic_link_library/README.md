
# DLL和进程的地址空间

dll由一组可供应用程序或其他dll使用的独立函数组成的源代码模块。 创建DLL文件映像时需要指定链接选项`/DLL`, 这个选项使生成DLL时与可执行文件生成差异信息。 

可执行程序在调用一个DLL中函数之前， 必须将该DLL文件映像映射到进程的地址空间中。通常有两种方法达到这一目的： 
- 隐式链接
- 显式链接

一旦系统将DLL文件映像映射到调用进程的地址空间后， 进程的所有线程就都可以调用DLL中的函数了。DLL中的任意函数创建的任意对象都为调用进程或线程所拥有。 如在DLL中调用了**VitualAlloc**, 系统会从调用进程地址空间中预定地址空间区域。 若之后撤销对DLL的映射， 那么这块空间区域仍保留预定状态。因为被预定区域为进程所拥有，只有当线程调用了VitualFree时才会被释放。

当运行同一个可执行程序多个实例时， 这些实例将不会共享可执行文件中的全局变量和静态变量。 Windows通过使用**写时复制**来保证这一点。

> 一个地址空间是由一个可执行模块和多个DLL模块构成。 在这些模块中有些会链接到C/C++运行库的静态版本， 有些为DLL版本。 甚至有些不需要C/C++运行库。 所以如下代码可能会出现异常:

```cpp
void* dllfunc()
{
    return (malloc(100));
}

void exefunc()
{
    void* pv = dllfunc();
    // some code....
    free(pv);
}
```
以上代码当所有模块都是引用的静态版本C/C++运行库， 则将出现异常。 若都是使用的动态库版本C/C++运行库则能够正常工作。 为了避免此类情况发生， 模块需同时提供申请与释放内存的接口。

究其根本， 为什么同时使用C/C++静态库版本时，会出现异常？ 因为C/C++运行库提供分配堆的API中利用`HeapAlloc`创建了私有堆, `new、delete、malloc、free`都是操作这个私有堆， 当进入模块的_DllMainCRTStartup方法时，此堆被创建。 而静态库时，模块多次被加载，各自创建了各自的堆；动态库仅会被加载一次， 所以仅创建了一次。  可调用`GetProcessHeap`验证此情况。 

上述说法源于博客[Windows内存体系--堆](https://blog.csdn.net/china_jeffery/article/details/79627032) 与 [Windows内存体系--跨MT模块的内存相互释放的问题](https://blog.csdn.net/china_jeffery/article/details/79656307)


# DLL工作方式



